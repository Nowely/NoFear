export const data = {
    lecture_1:{
        '0':{title:`                                                                                                                                   Модели данных. СУБД`},
        '1':{title:`        Данные - это совокупность сведений в форме, пригодной для хранения, передачи и обработки, которые зафиксированы на каком-либо носителе данных .
        Носитель - бумага, диск, пленке. Данные должны быть в форме, пригодной для хранения, передачи и обработки.
        Преобразование данных позволяет получить информацию. Таким образом, информацией можно назвать результат анализа и преобразования данных.
        В БД хранятся различные по типу и ограничениям данные, а система управления БД - СУБД может выдавать по определенному запросу требуемую информацию.
        Интерпретация данных – предназначена для определение смысла данных, формализации структуры и разъяснения кода.

        Информация = Данные + Интерпретации.`},
        '2':{title:`        Методы доступа к данным - это совокупность технических и программных средств, обеспечивающих возможность хранения и выборки данных, расположенных в БД.
        Последовательный метод доступа к данным характеризуется последовательным перебор всех данных со сравнением поискового признака.
        Прямой метод доступа к данным -это доступ по соответствию значения действительного ключа с физическим адресом хранения данного.
        Индексно-последовательный метод доступа к данным - это метод, включает в себя элементы последовательного перебора данных и элементы прямого доступа по индексной структуре.`},
        '3':{title:`Модель данных (Data Model) = структура данных + методы доступа.
        Составные части МД:
        
        Структура данных - представляет собой интерпретацию данных с описанием каждого атрибута, то есть семантическую и синтаксическую интерпретацию данных, хранящихся в БД. Обязательной частью структуры является ограничение целостности и правила согласованности данных, то есть набор правил, обеспечивающих защиту от неверных данных.
        Методы доступа -это совокупность технических и программных средств, обеспечивающих возможность хранения и выборки данных, расположенных в БД, то есть это перечень операций над данными.
        Ограничение целостности - это набор правил, обеспечивающий защиту от неверных данных.
        Типы МД:
        
        Иерархическая (1965-1970)
        
        Иерархическая МД применялась в начале 60-х годов - представляет собой древовидную структуру. Объекты такого типа имеют отношения между собой в виде «предок-потомок» подобно тому, как у дерева есть ствол, от которого идут ветки, а от каждой такой ветки идут ещё более маленькие веточки. Но в отличие от дерева в такой БД у какого-то одного предка может не быть потомков, с другой стороны их может быть довольно много, а каждый потомок, в свою очередь, может иметь только одного предка. Основным минусом такого типа состоит в том, что нет возможности реализовать структуру с множеством предков.
        Сетевая (1970 -1975)
        
        Сетевая МД является продолжением иерархических, они очень похожи, а разница между ними заключается в том, что в сетевых МД у потомка может быть сколько угодно предков. У них нет никаких ограничений в отношении связей между их объектами.
        Реляционная (1975-1980)
        
        Реляционная МД применяется начиная с 70-х годов - это самый распространённый вид и состоят они из таблиц. Каждая таблица состоит из строк и столбцов, строки называются записями, а столбцы – полями. Она была разработана доктором Коддом в 1970 году, в IBM.
        
        Таблицы ассоциируются прежде всего с реляционными БД, и иерархические, и сетевые могут быть также представлены в виде таблиц. Основное же различие этих видов - именно в принципе построения структуры: реляционные по сравнению с двумя остальными гораздо более свободные и менее упорядоченные.
        
        Достоинства РМД - простая математическая модель
        
        Недостатки РМД - утрачена семантика данных
        
        Отношение – это двумерная таблица, обладающую рядом свойств: нет одинаковых строк, столбцы – это поименованные логически связанные атрибуты с уникальным именем, порядок строк неупорядочен.
        
        Кортеж – это любая строка в отношении.
        
        Атрибут – это любой столбец в отношении.
        
        Домен – это множество неповторяющихся значений атрибута.
        
         Семантическая (1980-1985)
        
        Возникла из описания семантики языков. Среди основных особенностей выделяются: все объекты в процессе работы могут быть связаны; логическая близость приводит к близкому расположению; в процессе работы можно менять схему БД.
        Типово – полная (1985-1990)
        
        Представляет собой теоретический подход к описанию сложных структур. Есть сложные типы, но нет концепции ООП.
        Основные понятия: простые типы данных (TEXT, INT, REAL, DATA…); конструкторы новых типов из простых и ранее описанных типов; возможна любая суперпозиция типов. Нет ограничения на глубину и ширину.>
        
         Объектно – ориентированная (1990-1995)
        
        ООМД создана для хорошего взаимодействия данных с объектно-ориентированными языками программирования, поэтому они обладают тем же набором характеристик, что и эти языки программирования.
        Основные свойства:
        
        Многократное использование типов. Абстракция. Классы представляют собой ни что иное, как абстрактные типы данных и все является членом какого-то класса.
        Внутреннее представление данных и деталей реализации общедоступных и частных методов (программ) является частью определения класса. Инкапсуляция. Иерархия типов.
        Классы определены как часть иерархии классов. Наследование. Определение каждого класса более низкого уровня наследует свойства и методы его родителя.
        Переопределение операций над данными. Полиморфизм.
        Структура данных в ООБД очень узко-специализирована. Сложные структуры данных такой БД образуют объект и работают непосредственно с языками объектно-ориентированного программирования.
        
        Многомерная (1995-2000)
        
        ММД в основном используется для систем оперативного анализа - OLAP (On Line Analytical Processing) База данных – многомерный куб Свойства: Возможность агрегации (Например: Область, район, город) Историчность (есть временная ось) Статичность (данные в многомерном кубе не изменяются во время проведения анализа)
        Основные понятия: Измерение (dimension) Ячейка (cell) Срез (slice) подмножество - куб меньшей размерности
        
        Пример ММД: Ячейки (cell) – объем продаж в денежном выражении.`},
        '4':{title:`        База данных (БД) - это совокупность данных, хранимых в соответствии со схемой данных, манипулирование которыми выполняют в соответствии с правилами и средствами моделирования данных.
        БД по сути это хранилище или контейнер для некоторого набора файлов данных. Фактически это просто файлы с текстовыми записями, имеющие минимальную структуризацию.
        
        Система управления базами данных (СУБД) - это совокупность языковых и программных средств, обеспечивающих создание, использование и ведение базы данных.

        Основные задачи СУБД:
        • сохранить целостность данных;
        • обеспечить быстрый и безопасный доступ к данным;
        • реализовать запрошенные преобразования.

        Основные функции СУБД:
        • Управление данными во внешней памяти. Происходит либо средствами ОС, либо средствами самой СУБД;
        • Управление буферами оперативной памяти
        • Управление транзакциями. Пока система не завершила транзакцию, БД находится в состоянии до начала транзакции. Если транзакция не завершилась и возникла ошибка, то выполняется откат (rollback).
        • Если транзакция завершена успешно (commit), то старое состояние БД удаляется и база переходит в текущее состояние.
        
        Журнализация - сохранение информации, необходимой для восстановления базы данных в случае логических или физических сбоев. Все изменения БД вносятся сначала в специальный файл (журнал). Затем при сохранении или закрытии БД этот файл записывается на диск (применяются изменения).
        Архивирование (создание архивных копий).
        Поддержка языков БД. Основной язык SQL = DDL + DML.`},
        
    },
    lecture_2:{
        '0':{title:`                                                                                                                                   Концептуальной проектирование`},
        '1':{title:`     Этапы разработки:

        •Планирование разработки БД

            ○Планирование наиболее эффективного способа реализации этапов жизненного цикла как самой БД так и ИС
        
                ▪Прикладной подход
                ▪Предметный подход
                ▪Инфраструктура
    •Определение требований к системе

        ○Определение диапазона действий и границ приложения с БД, состава его и области применения
        
                ▪Архитектура Клиент-сервер
                ▪Система безопасности
    •Сбор и анализ требований пользователей

        ○Сбор и анализ требований пользователей из всех возможных областей применения
        
                ▪Регламенты пользователей
                ▪Агрегирование пользовательских запросов

    •Проектирование БД (Выбор целевой СУБД)

        ○Полный цикл разработки включает концептуальное, логическое и физическое проектирование БД
        
        ○Выбор наиболее подходящей СУБД выполняется в этапе Проектирование БД на физическом этапе проектирования
        
    •Разработка приложений

        ○Определение пользовательского интерфейса и прикладных программ, которые используют и обрабатывают данные в БД
        
            ▪Проектирование прикладных программ
            ▪Проектирование клиентского функционала
    •Создание прототипа

        ○Создание рабочей модели приложения БД, к-ая позволяет разработчикам и пользователям представить и оценить-протестировать вид и функциональность системы
        
    •Реализация

        ○Создание внешнего, концептуального и внутреннего определений БД и прикладный программ
        
    •Преобразование и загрузка данных

        ○Преобразование и загрузка данных (и прикладных программ) из старой системы во вновь разрабатываемую
        
    •Итоговое тестирование

        ○Приложение БД тестируется с целью обнаружения ошибок, а также его проверки на соответствие всем требованиям, выдвинутым пользователями
        
    •Эксплуатация и сопровождение

        ○На этом этапе приложение БД считается полностью разработанным и реализованным
        
        ○В случае необходимости в изменении функционала необходимо повторное проведение части этапов`},
        '2':{title:`        Прикладной подход   

            •определяется прикладным приложением, под которое разрабатывается БД
            •характерно наличие запросов пользователя под регламентами
            •крайне затруднено развитие/масштабирование БД

        Предметный подход
        
            •определяется картиной предметной области задачи из реального мира
            •характерно наличие свободных/произвольных запросов пользователей
            •планируется изначально возможное развитие/масштабирование БД`},
        '3':{title:`        Критерии выбора СУБД - решается в два этапа:

        
            •Качественная оценка
            •Количественная оценка

        Качественная оценка:
        
            •модель данных (к1)
            •удобство и простота использования (к2)

        –понятные процедуры установки программных продуктов,
        
        –удобный и унифицированный интерфейс конечного пользователя,
        
        –простота выполнения обычных операций: создания БД, навигации, модификации, подготовки данных, выполнения запросов и отчетов и ряда других;
        
        –наличие интеллектуальных подсистем подсказок, помощи в процессе работы и обучения, включая примеры;
        
            •качество средств разработки (к3)

        –возможности создания пользовательских интерфейсов,
        
        –мощность языка создания программ,
        
        -автоматизация разработки различных объектов: экранных форм, отчетов, запросов;
        
            •качество средств защиты БД (к4)

        –доступ к функциям защиты на уровне средств разработки программ
        
        –доступ к функциям защиты на уровне пользователя.
        
            •качество средств контроля корректности БД (к5)

        –обеспечение уникальности записей БД по первичному ключу,
        
        –автоматический контроль целостности связей между таблицами во время выполнения операций обновления, вставки и удаления записей,
        
        –проверка корректности значений в БД;
        
            •качество коммуникационных средств (к6)

        –поддержку сетевых протоколов,
        
        –поддержку стандартных интерфейсов с БД,
        
        –наличие средств групповой работы с информацией БД,
        
        –способность использовать и модифицировать БД других форматов без импортирования или преобразования;
        
    Количественная оценка:
        
        •Архитектурные возможности СУБД (1)
        •Коммуникационные возможности СУБД (2)
        •Функциональные возможности СУБД (3)
        •Средства разработки БД (4)
        •Эффективность работы СУБД (5)
        •Надежность работы СУБД (6)
        •Требования к рабочей среде (7)
        •Особенности разработки приложений (8)
        •Финансовые критерии (9)
        •Социальные критерии (10)`},
        '4':{title:`        Восходящий подход : 

        Алгоритм исполнения (нормализация):

        • Начинается с самого нижнего уровня атрибутов;
        • Анализируются связи между атрибутами
        • Происходит агрегация
        • Формируются отношения
        • Представляются типы сущностей и связи между ними

        Применение: для проектирования простых БД с небольшим количеством атрибутов, которые очевидны и гарантированно однозначно выделяются при первичном рассмотрении задачи

        • Недостатки:
        • в крупных БД невозможно установить и гарантировать полный
        перечень атрибутов
        • установить среди большого количества атрибутов все
        существующие функциональные зависимости затруднительно
        
        Нисходящий подход :

        Алгоритм исполнения (модель Сущность-Связь):

        • Начинается с выделения сущностей и связей очень высокого
        уровня;
        • Открывается цикл до выделения атрибутов самого нижнего
        уровня
        • Выделяются подчиненные сущности
        • Формируются связи
        • Выделяются все атрибуты сущностей и связей в это итерации

        Применение: для проектирования сложных БД с большим количеством атрибутов.

        •Недостатки:
        • в крупных БД невозможно установить и гарантировать полный
        перечень атрибутов
        • установить среди большого количества атрибутов все существующие функциональные зависимости затруднительно.`},
        '5':{title:`        ER-модель

        Типы связей:
        
        •Один-к-одному – один кортеж, принадлежащий отношению1 связан с один кортежем из отношения2
        •Один-ко-многим - один кортеж, принадлежащий отношению1 связан с несколькими кортежами из отношения2
        •Многие-к-одному - много кортежей, принадлежащий отношению1 связаны с один кортежем из отношения2
        •Многие-ко-многим - много кортежей, принадлежащий отношению1 связаны со многими кортежами из отношения2

        Типы сущностей
        
        •Стержневая сущность (стержень) – это главная независимая сущность 
        •Ассоциативная сущность (ассоциация) – это связь вида "многие-ко-многим":
        •они могут участвовать в других ассоциациях и обозначениях точно так же, как стержневые сущности;
        •могут обладать свойствами
        •Характеристическая сущность (характеристика) – это связь вида "многие-к-одной" или "одна-к-одной" между двумя сущностями (частный случай ассоциации). 
        Характеристика описывает или уточняет некоторый другие сущности
        •Обозначающая сущность или обозначение – это связь вида "многие-к-одной" или "одна-к-одной" между двумя сущностями и отличается от характеристики тем,
        что не зависит от обозначаемой сущности.

        Модель Чена
        
        •Сущности – прямоугольники
        •Связи/Отношения – ромбы с указанием типа связи из ER-модели в вершинах, из которых выходят линии связи:
        •Если сущность участвует в отношении, они связаны линией
        •Если отношение не является обязательным, то линия пунктирная
        •Атрибуты – овалы, которые соединены линией с принципиально одним отношением или с принципиально одной сущностью
        `},
        
    },
    lecture_3:{
        '0':{title:`                                                                                                                                   Логическое проектирование. Нормализация`},
        '1':{title:`       Логическое проектирование

        • Процесс создания модели данных по используемой у
        заказчика информации, на основе выбранной модели
        данных, но не зависящей от СУБД и любых физических
        аспектов ее представления
        • Проверка на соответствии требований пользователей и
        модели производится с меньшей периодичностью
        • Нормализация как проверка правильности логической
        модели
        • Логическая модели играет важную роль на этапе
        эксплуатации и сопровождения готовой системы
        • Необходима нормализация – разрезка на двумерные
        таблицы. НФ – нормальная форма.
        • Инструмент для рисования моделей: dbdesigner.net.

        •Erwin и BPWIN  Data Modeler - Case-технология`},
        '2':{title:`        Нормализация

        1НФ

            •Определение: БД находится в 1НФ, если во всех отношениях все атрибуты атомарны (неделимы). Атомарность следует из ограничений доменной организации,
            при которой в домене могут быть только однотипные данный простой структуры. То есть в одном поле не могут находиться данные состоящие, например,
            из числа и строки или из нескольких чисел или строк (то есть фактически из массивов), которые ВАЖНО надо рассматривать как отдельные значения. 
            Если же нет необходимости рассматривать разнотипные данные или сложные структур данных в атрибуте как отдельные элементы, то даже сложные на вид данные можно принять как атомарные.

        Достоинства
        
            •увеличение эффективности работы запросов на выборку за счет атомарности атрибутов

        Недостатки
        
            •Избыточность
            •Все процессы по модификации данных: вставка, удаление и обновление будут теперь усложнятся необходимостью заполнения нескольких полей одновременном для семантически связанного,
            то есть одного свойства разделенного на несколько атрибутов

        2НФ

            •Определение: БД находится во 2НФ, если она в 1НФ и каждый не ключевой атрибут функционально полно зависит от ключа.
            •Доп. определение: Функционально полная зависимость – зависимость от ключа в целом (не от части ключа, если ключ совокупность атрибутов).

        Достоинства:
        
            •помогает избежать аномалий модификации данных
            •максимально разбить модель данных на отдельные отношения, чтобы их можно было комбинировать
            •минимизирование усилии по изменению схемы в случае необходимости
            •выявление ключевых зависимостей в модели

        Недостатки:
        
            •Избыточность – многократное повторение кода города
            •искусственное создание классификаторов

        Ключ или Потенциальный ключ – это минимальный набор атрибутов, по значению которых можно однозначно выбрать требуемый экземпляр сущности. Обладает свойствами:
        
            •Уникальность
            •Не избыточности

        По способу общности ключи бывают:
        
            •Простой – сформирован из одного атрибута
            •Составной – сформирован из набора атрибутов

        По способу создания ключи бывают:
        
            •Естественный – основан на атрибуте/ах существующих естественным образом в сущности
            •Суррогатный - основан на атрибуте/ах не существующих естественным образом в сущности и вводимых в сущность искусственным добавлением. 
            Суррогатные ключи ОЧЕНЬ часто применяются в РБД, основная причина заключается в том, что такие искусственно введенные поля можно отдать в полный контроль СУБД на автоматическую
            генерацию в этих полях данных, которые таким образом гарантированно (без ошибок) будут сгенерированы, то есть не будет пустых ячеек, и точно  будут уникальными значениями. 
            Кроме того, введение так называемых айдишников стало привычным для разработчиков РБД и серьезно упрощает сопровождение при эксплуатации РБД, 
            и даже влияет в уменьшение размерности РБД.

        3НФ

            •Определение: БД находится во 3НФ, если она во 2НФ и каждый не ключевой атрибут не транзитивно зависит от ключа.
            •Доп. определение: транзитивная зависимость – это когда есть в отношении три атрибута А, Б и В. И они оказывают влияние вида А на Б, Б на В, 
            следовательно получается что А и В тоже зависят. Хотя последняя зависимость явно в отношении может не просматриваться.

        Достоинства:
        
            •уменьшение повторений значений атрибутов в отдельных отношениях
            
        Недостатки:
        
            •увеличение количества отношений с усугублением сложности интерпретации семантической связанности

        BCNF усиление 3НФ - НФ Бойса-Кодда
        
        Определение: Отношение находится в 3НФ и детерминанты всех её функциональных зависимостей являются потенциальными ключами. Отношение находится в 3НФ нет не ключевых атрибутов, 
        находящихся в функциональной зависимости от отдельных полей первичного ключа.
        
        Ситуация, когда отношение будет находиться в 3НФ, но не в BCNF, возникает, например, при условии, что отношение имеет два (или более) потенциальных ключа, которые являются составными,
        и между отдельными атрибутами таких ключей существует функциональная зависимость.
        
        4НФ
        
            •Определение: БД находится в 4НФ, если она в 3НФ и в каждом отношении не более одной многозначной зависимости.
            •Многозначная зависимость в отношении выделяется, когда в одном отношении находятся два и более наборов атрибутов, которые не зависят друг от друга. 
            То есть явно видно, что это отношение состоит из двух и более независимых частей. Если отношение явно разделяется на 2 и более независимых набора атрибутов, 
            то его следует разделить физически на два и более отношений.

        Достоинства:
        
            •атрибуты имеют многозначную зависимость от потенциального ключевого атрибута что обеспечивает декомпозицию, основанную на многозначных зависимостях
            •дает возможность выделить множество многозначных зависимостей в отношении и сгруппировать их отдельными отношениями

        Недостатки:
        
            •искусственное введение лишних отношений, которые не наделены семантическим значением

        5НФ

            •5НФ – проекционно-соединительной нормальной форме
            •Определение: Отношение находится в 5НФ когда находится в 4НФ и каждаянетривиальная зависимость соединения в нём определяется потенциальным ключом (ключами) этого отношения
            •5НФ является окончательной нормальной формой в контексте операций проекции и соединения
            •Любая переменная отношения может быть подвергнута декомпозиции без потерь на эквивалентный набор переменных отношения в 5НФ, то есть 5НФ всегда достижима.
            •Очень редко отношение, находящееся в 4НФ, не соответствует 5НФ.

        6НФ

            •Введена Кристофером Дейтом для обобщения 5НФ
            •Определение: отношения находится в 6НФ когда оно соответствует 5НФ и удовлетворяет всем нетривиальным зависимостям соединения. То есть 
            отношение находится в 6НФ когда оно неприводимо - не может быть подвергнуто дальнейшей декомпозиции без потерь.
            •Актуально для хронологических данных в РБД.
            •Упрощает поддержания целостности в хронологических БД`},
        '3':{title:`        Критерии оценки модели БД:
        • Структурная достоверность: соответствие данных и их связей
        представлению данных и их логической/семантической связанности в
        предметной области и задачи.
        • Простота: понимание не разработчиком модели без дополнительных
        описаний и соответствующей документации.
        • Выразительность: определяется наличие запланированной
        интерпретации всего многообразия объектов и связей предметной
        области задачи в информационных структурах модели
        • Отсутствие избыточности: отношения максимально оптимизированы по
        составу атрибутов в представлены в однократном повторение.
        • Способность к совместному использованию: отсутствует связь в МД с
        планируемым использованием в клиентских приложениях и технологиях.
        • Расширяемость: спланировано возможное развитие МД, направленной
        на расширение не дополнительными отношениями, а максимально без
        участия разработчиков.
        • Целостность:
        • Схематическое представления: модель может быть представлена и не
        в графическом виде, но именно схема определяет дополнительно
        наглядное представление модели.`},
        '4':{title:`Нотация IDEF1X

        Сущности
            •Сущность имеет уникальное имя. Именем сущности является имя существительное. Имя сущности указывается над блоком
            •Сущность обладает одним или несколькими атрибутами

        Атрибуты
            •Атрибуты изображаются в виде списка их имен и меток внутри блока сущности.
            •Каждый атрибут имеет уникальное имя. Именем атрибута является имя существительное.
            •Атрибуты первичного ключа («№ лич.дела») располагаются в начале списка и отделяются от других атрибутов горизонтальной чертой.
            •Атрибуты альтернативного ключа («серия паспорта», «номер паспорта») могут быть помечены меткой AKn.m, где n – номер ключа, m – номер атрибута в ключе. 
            •Внешний ключ («номер отдела») имеет метку FK

        Связи

            •Указываются индикаторы ограничений ссылочной целостности при выполнении вставки, обновления и удаления экземпляров связанных сущностей.
            •Ограничения ссылочной целостности – это правила, которые ограничивают выполнение корректирующих операций вставки (Insert), 
            обновления (Update) и удаления (Delete) экземпляров сущностей, одна из которых является родителем (Parent), а другая – потомком (Child):
            •RESTRICT (запретить) – не разрешать выполнение операции, приводящей к нарушению ссылочной целостности.
            •CASCADE (каскадировать) – разрешить выполнение требуемой операции, но внести при этом необходимые поправки в других сущностях так, 
            чтобы не допустить нарушения ссылочной целостности и сохранить все имеющиеся связи. 32
            •SET NULL (установить в Null) – разрешить выполнение требуемой операции, но все возникающие некорректные значения внешних ключей изменять на неопределенные (Null) значения.
            •SET DEFAULT (установить по умолчанию) – разрешить выполнение требуемой операции, но все возникающие некорректные значения внешних ключей изменять на некоторое значение,
            принятое по умолчанию.
            •NO ACTION (игнорировать) – выполнять операции, не обращая внимания на нарушения ссылочной целостности.
            •NONE – не требуется обеспечение ссылочной целостности.`},
        '5':{title:`        Трансформационная модель - это модель данных, которая удовлетворяет условиям 3 нормальной формы, т.к. она оптимизирована для использования в рамках конкретной
        СУБД с учетом ее особенностей и возможностей

            •Процесс подготовки описания реализации БД с учетом целевой СУБД
            •Рассматриваются организация файлов и индексов, ограничения целостности и средства защиты
            •В результате физического проектирования Проектировщик принимает решение о способах реализации разрабатываемой БД
            •Между логическим и физическим этапом проектирования есть постоянная связь, т.к. повышение производительности на физ. Этапе влечет к изменению структуры логической модели

        Физическое проектирование для реляционной МД:
        
            •Создание набора таблиц и ограничений для них
            •Определение конкретных структур хранения данных и методов доступа к ним с учетом максимальной производительности СУБД
            •Разработка средств защиты`},
    },
    lecture_4:{
        '0':{title:`                                                                                                                                   Реляционная алгебра`},
        '1':{title:`        Реляционная алгебра
        Автор – британский математик Эдгар Кодд (Codd) в 1972г.
        • Реляционная модель – совокупность изменяющихся
        во времени нормализованных отношений
        • Нормализованное отношение – все данные атомарны
        Понятия:
        • Отношение (relation) - Таблица (двумерный массив)
        • Кортеж <d1
        , d2 , …, dk> - Запись
        • Домен di Є D - Множество допустимых значений.`},
        '2':{title:`        Реляционное исчисление является прикладной ветвью
        формального механизма исчисления предикатов первого порядка.
        В основе исчисления лежит понятие переменной с определенной
        для нее областью допустимых значений и понятие правильно
        построенной формулы, опирающейся на переменные, предикаты и
        кванторы.
        В зависимости от того, что является областью определения
        переменной, различают исчисление кортежей и исчисление
        доменов:
        • В исчислении кортежей областями определения переменных
        являются тела отношений базы данных, т. е. допустимым
        значением каждой переменной является кортеж тела
        некоторого отношения.
        • В исчислении доменов областями определения переменных
        являются домены, на которых определены атрибуты отношений
        базы данных, т. е. допустимым значением каждой переменной
        является значение некоторого домена. 

        Реляционная алгебра и реляционное исчисление представляют собой формальные языки, для которых требование дружественности по отношению к пользователю не стоит на первом месте. 
        В реляционных БД они использовались в качестве основы при разработке других языков более высокого уровня для управления данными.`},
        '3':{title:`        Объединение:
        • При выполнении операции объединения ( UNION ) двух отношений с одинаковыми заголовками производится
        отношение, включающее все кортежи, которые входят хотя бы в одно из отношений-операндов.
        • результатом объединения двух множеств A{a} и B{b} является такое множество C{c}, что для каждого с либо
        существует такой элемент a, принадлежащий множеству A, что c=a, либо существует такой элемент
        b, принадлежащий множеству B, что c=b;
        • Т1 и Т2 с одинаковыми схемами {Иден, ИМЯ, Номер}. Строгое совпадение количества атрибутов, доменов и
        их последовательности перечисления.Т1 UNION Т2 позволит получить информацию обо всех записях, из двух таблиц. 
        Пересечение:
        • Операция пересечения ( INTERSECT ) двух отношений с одинаковыми заголовками производит отношение,
        включающее все кортежи, которые входят в оба отношения-операнда.
        • Пересечением множеств A и B является такое множество C{c}, что для любого c существуют такие
        элементы a, принадлежащий множеству A, и b, принадлежащий множеству B, что c=a=b;
        • Т1 INTERSECT Т2 позволит получить данные о записях, которые одновременно участвуют в двух таблицах.
        Разность:
        • Отношение, являющееся разностью ( MINUS ) двух отношений с одинаковыми заголовками, включает все
        кортежи, входящие в отношение-первый операнд, такие, что ни один из них не входит в отношение, которое является вторым операндом.
        • разностью множеств A и B является такое множество C{c}, что для любого c существует такой элемент a,
        принадлежащий множеству A, что c=a, и не существует такой элемент b, принадлежащий B, что c=b.
        • Т1 MINUS Т2 2 вернет отношение, содержащее кортежи записей, которые участвуют только в первой таблице.
        Декартово произведение:
        • При выполнении декартова произведения ( TIMES ) двух отношений, пересечение заголовков которых
        пусто, производится отношение, кортежи которого производятся путем объединения кортежей первого и второго операндов.
        • Пусть имеются два отношения R1{a1, a2, …, an} и R2{b1,b2, …, bm}. Тогда результатом операции R1 TIMES R2 является отношение R{a1, a2, …, an, b1, b2, …, bm}, тело
        которого является множеством кортежей вида {ra1, ra2,…, ran, rb1, rb2, …, rbm} таких, что {ra1, ra2, …, ran} входит в тело R1, а {rb1, rb2, …, rbm} входит в тело R2 .
        • Операция взятия декартова произведения не является слишком осмысленной на практике.`},
        '4':{title:`        Ограничения:
        Операция ограничения WHERE требует наличия двух операндов: ограничиваемого отношения и простого условия ограничения. Простое условие ограничения может иметь:
        • Вид ( a comp-op b ), где а и b – имена атрибутов ограничиваемого отношения; атрибуты a и b должны быть определены на одном и том же домене, для значений базового типа
        данных которого поддерживается операция сравнения comp_op, или на базовых типах данных, над значениями которых можно выполнять эту операцию сравнения;
        • Или вид ( a comp-op const ), где a – имя атрибута ограничиваемого отношения, а const – литерально заданная константа; атрибут a должен быть определен на домене или
        базовом типе, для значений которого поддерживается операция сравнения comp_op.
        Операцией сравнения comp-op могут быть " = ", " > ", " < ".
        A WHERE (comp1 AND comp2) обозначает то же самое, что и (A WHERE comp1)
        INTERSECT (A WHERE comp2) ;
        A WHERE (comp1 OR comp2) обозначает то же самое, что и (A WHERE comp1) UNION (A
        WHERE comp2) ;
        A WHERE NOT comp1 обозначает то же самое, что и A MINUS (A WHERE comp1).
        Результатом ограничения ( WHERE ) отношения по некоторому условию является отношение, включающее кортежи отношения-операнда, удовлетворяющее этому условию.
        Это классическое условие на языке SQL

        Проекция:
        Операция взятия проекции также требует наличия двух операндов – проецируемого отношения A и подмножества множества имен атрибутов, входящих в заголовок отношения A.
        PROJECT T1 {Номер}
        При выполнении проекции ( PROJECT ) отношения на заданное подмножество множества его атрибутов производится отношение, кортежи которого являются
        соответствующими подмножествами кортежей отношения-операнда.

        Соединение:
        Общая операция соединения (называемая также соединением по условию) требует наличия двух операндов – соединяемых отношений и третьего операнда – простого условия.
        Пусть соединяются отношения A и B. Как и в случае операции ограничения, условие соединения comp имеет вид либо ( a comp-op b ), либо ( a comp-op const ),
        где a и b – имена атрибутов отношений A и B, const – литерально заданная константа, и comp-op – допустимая в данном контексте операция сравнения.
        Тогда по определению результатом операции соединения A JOIN B WHERE comp совместимых по взятию расширенного декартова произведения отношений A и B
        является отношение, получаемое путем выполнения операции ограничения по условию comp расширенного декартова произведения отношений A и B
        Если тщательно осмыслить это определение, то станет ясно, что в общем случае применение условия соединения существенно уменьшит мощность результата
        промежуточного декартова произведения отношений-операндов только в том случае, если условие соединения имеет вид ( a comp-op b ), где a и b – имена атрибутов разных отношений-операндов.
        T1 JOIN T2 WHERE (P1{T2.P1}> P1{T1.P1})
        При соединении ( JOIN ) двух отношений по некоторому условию образуется результирующее отношение, кортежи которого производятся путем объединения
        кортежей первого и второго отношений и удовлетворяют этому условию.

        Деление:
        Эта операция наименее очевидна из всех операций реляционной алгебры Кодда. Пусть заданы два отношения – A с заголовком {a1, a2, ..., an, b1, b2, ..., bm} и B с
        заголовком {b1, b2, ..., bm}. Будем считать, что атрибут ai отношения A и атрибут bi отношения B (i = 1, 2, …, m) не только обладают одним и тем же именем, но и
        определены на одном и том же домене. Назовем множество атрибутов {aj} составным атрибутом a, а множество атрибутов {bj} – составным атрибутом b.
        После этого будем говорить о реляционном делении "бинарного" отношения A{a,b} на унарное отношение B{b}.
        По определению, результатом деления A на B (A DIVIDE BY B) является "унарное" отношение C{a}, тело которого состоит из кортежей v таких, что в теле отношения A
        содержатся кортежи v UNION w такие, что множество {w} включает тело отношения B.
        T1 DIVIDE BY T2
        У операции реляционного деления ( DIVIDE BY ) два операнда – бинарное и унарное отношения. Результирующее отношение состоит из унарных кортежей,
        включающих значения первого атрибута кортежей первого операнда таких, что множество значений второго атрибута (при фиксированном значении первого атрибута)
        включает множество значений второго операнда.`},
        '5':{title:`        Переименование:
        Операция переименования ( RENAME ) производит отношение, тело которого совпадает с телом операнда, но имена атрибутов изменены.
        Операция присваивания ( := ) позволяет сохранить результат вычисления реляционного выражения в существующем отношении БД.
        
        Приоритет операций:
        Поскольку результатом любой реляционной операции (кроме операции присваивания, которая не вырабатывает значения) является некое отношение,
        можно образовывать реляционные выражения, в которых вместо отношения-операнда некоторой реляционной операции находится вложенное
        реляционное выражение. В построении реляционного выражения могут участвовать все реляционные операции, кроме операции присваивания.
        Вычислительная интерпретация реляционного выражения диктуется установленными приоритетами операций:
        RENAME >= WHERE = PROJECT >= TIMES = JOIN = INTERSECT = DIVIDE BY >= UNION = MINUS.
        `},
    },
    lecture_5:{
        '0':{title:`                                                                                                                                   Операторы DDL и DML. Таблицы, триггеры процедуры`},
        '1':{title:`        Язык SQL
        Structured Query Language — «язык структурированных запросов 
        SQL является - информационно-логическим языком, предназначенный для описания хранимых данных, для извлечения хранимых данных и для модификации данных. 
        Первые стандарты языка SQL - SQL1:
        • 1986- Американский Национальный Институт 
        Стандартов - ANSI
        • 1987 - Международная организация по стандартизации 
        - ISO

        История версий стандарта SQL:
        1986. SQL-86,SQL-87/SQL1. Первый вариант стандарта, принятый институтом ANSI и одобренный ISO в 1987 году.
        1989. SQL-89/ SQL1. Немного доработанный вариант предыдущего стандарта.
        1992. SQL-92/SQL2. Значительные изменения (ISO 9075); уровень Entry Level стандарта SQL-92 был принят как стандарт FIPS 127-2.
        1999. SQL-99/SQL3. Добавлена поддержка регулярных выражений, рекурсивных, запросов, поддержка триггеров, базовые процедурные расширения, не скалярные 
        типы данных и некоторые объектно-ориентированые возможности.
        2003. SQL-2003. Введены расширения для работы с XML-данными, оконные функции (применяемые для работы с OLAP-базами данных), генераторы 
        последовательностей и основанные на них типы данных.
        2006. SQL-2006. Функциональность работы с XML-данными значительно расширена. Появилась возможность совместно использовать в запросах SQL и XQuery.
        2008. SQL-2008. Улучшены возможности оконных функций, устранены некоторые неоднозначности стандарта SQL:2003
        2016. SQL-2016. В настоящее время является последним.

        Соответствие стандарту:
        Впервые понятие «уровня соответствия» было предложено в стандарте SQL-92. ANSI определяли четыре уровня соответствия 
        реализации этому стандарту, где каждый последующий уровень соответствия заведомо подразумевал соответствие предыдущему уровню:
        • Entry (базовый) 
        • Transitional (переходный)
        • Intermediate (промежуточный) 
        • Full (полный)
        С введением стандарта SQL-99 и до сих пор все разделено на модули — основная часть стандарта была вынесена в раздел SQL/Foundation, всѐ остальное вынесено в отдельные модули. 
        Соответственно, остался только один уровень совместимости во всех СУБД — что означает поддержку этой основной части. Поддержка остальных возможностей оставлена на усмотрение 
        производителей СУБД. 
    `},
        '2':{title:`        Операторы DDL
        Create - СОЗДАТЬ
        Alter - ИЗМЕНИТЬ
        Drop - УДАЛИТЬ

        Создание таблиц:
        CREATE TABLE имя_таблицы (имя_столбца тип_данных [NULL | NOT NULL] [CONSTRAINTS], имя_столбца тип_данных[NULL|NOT NULL] [CONSTRAINTS] , ..... );
        Ограничения:
        • На пустое значение
        • На значение по умолчанию
        • На определенные ранее параметры

        Пример ключей в таблицах:
        • Создание таблицы с простым первичным ключем: CREATE TABLE таблица1 (ID_1 int not null primary key, Name_T1 char(3))
        • Создание таблицы с простым внешним ключем: CREATE TABLE таблица2 (ID_1 int not null, ID_2 int not null, Name_T1 char(3), ID_1_таблица1 int references таблица1(ID_1))
        • Изменения таблицы на добавление ограничения составного первичного ключа: ALTER TABLE таблица1 ADD CONSTRAINT имя_ограничения Primary key(поле1, поле2)
        • Изменения таблицы на добавление составного внешнего ключа: ALTER TABLE таблица2 ADD FOREIGN KEY (поле2_изтаблица2_для_FK) REFERENCES таблица1(поле1_изтаблица1_для_РK);

        Общий вид, изменения таблиц:
        ALTER TABLE имя таблицы ADD | DROP имя_столбца тип_данных [NULL | NOT >NULL]  [CONSTRAINTS] ,  ADD I DROP имя_столбца тип_данных [NULL|NOT >NULL]  [CONSTRAINTS],
        Изменения не только структуры но и целостности.

        Изменения таблиц в примерах:
        Переименование полей: EXEC sp_rename 'Имя таблицы.Старое имя поля', 'Новое имя поля', 'COLUMN' 
        Добавление полей: ALTER TABLE таблица1 ADD поле5 VARCHAR(30) NOT NULL
        Добавление/удаление ключевой связи: ALTER TABLE таблица1 DROP CONSTRAINT Имя_ограничения_FK_ключа
        Изменение типов полей: Замена типов при пустых колонках 
        ALTER TABLE таблица1 ALTER COLUMN поле1 новый_тип

        Удаление объектов:
        DROP ТИП_ОБЪЕКТА имя_объекта;
        ТИП_ОБЪЕКТА:
        Table- таблица
        Trigger- триггер
        Procedure- процедура
        Generator- генератор
        Exception– исключение
        VIEW– просмотр
        INDEX – индекс
        Foreign key – внешний ключ
        Primary key – первичный ключ

        Создание объектного типа PROCEDURE, TRIGGER:
        CREATE ТИП_ОБЪЕКТА имя_объекта
        [параметры) [опции] 
        AS
        begin
         SQL
        end;
        Для Procedure, Function
        • Входные параметры
        • Выходные параметры
        Для Trigger нет входных параметров и возвращаемых значений`
    },
        '3':{title:`        Что такое Триггер:
        Триггер – это хранимая процедура, которая вызывается автоматически СУБД на действие с данными (DML) или структурой БД (DDL).
        Триггер – это хранимая процедура, которую пользователь вызывает не напрямую, а действием по модификации данных типа добавлением - INSERT, удалением -DELETE, изменением - UPDATE. 

        Создание/редактирование Триггеров:
        CREATE/ALTER 
            TRIGGER name ON table
            [ACTIVE | INACTIVE] 
            {FOR| AFTER| INSTEAD OF} 
            {DELETE | INSERT | UPDATE} 
            [POSITION number] 
        AS 
        DECLARE VARIABLE variable <datatype>; 
        [DECLARE VARIABLE variable <datatype>; ...] 
        BEGIN
        <compound_statement> [<compound_statement> ...] 
        END 

        Последовательность вызова Триггера:
        T-SQL sp_settriggerorder @triggername = 'Имя триггера', 
        @order = 'позиция', @stmttype = 'операция‘
        Order: first, last, none
        Stmttype: insert, update, delete

        Операторы работы с Триггерами;
        Create – создать
        Alter - изменить
        Drop – удалить 
            DROP TRIGGER [ IF EXISTS ] 
            [schema_name.]trigger_name [ ,...n ] [ ; ]
        Enable – активировать
            ENABLE TRIGGER { [ schema_name . ] 
            trigger_name [ ,...n ] | ALL } ON { object_name | 
            DATABASE | ALL SERVER } [ ; ] 
        Disable – выключить 
            DISABLE TRIGGER { [ schema_name . ] trigger_name
            [ ,...n ] | ALL } ON { object_name | DATABASE | ALL 
            SERVER } [ ; ] `
        },
        '4':{title:`        Процедуры и функции:
        Процедуры – это блок операторов, сохраняемых в БД, которые позволяют сохранить часто используемую логику приложений. 

        При выполнении все операторы выполняются как единое целое.

        Процедуры функции возвращают значений вызывающей его программе.

        Основная задача процедур модифицировать данные в таблицах.

        Основная задача функций модифицировать/преобразовывать 
        отдельные данные.

        CREATE PROCEDURE:
        CREATE (ALTER) PROCEDURE имя_процедуры
            @имя_переменной тип_переменной 
            = default 0 ;
            @имя_переменной тип_переменной OUTPUT
        AS 
        BEGIN 
            Код процедуры; 
            RETURN;
        END; 
        EXECUTE/EXEC/CALL имя_процедуры

        CREATE FUNCTION:
        CREATE (Alter) FUNCTION имя_функции
            (@имя_параметра [ AS ] тип параметра) 
            RETURNS возвращаемый тип
        AS 
        BEGIN 
            Код функции; 
            RETURN параметр; 
        END

        Вызов функции:
        Вызов как части выражения (внутри запросов :
            • SELECT
                • SELECT имя_функции (параметры), Поле1 FROM 
                Таблица1 
                • SELECT имя_функции (Поле1) FROM Таблица1 или 
                SELECT имя_функции (параметры) 
                • в WHERE, HAVING; 
                • в GROUP BY; 
        • INSERT 
            • в VALUES; 
        • UPDATE
            • в SET; 
        EXECUTE имя_функции (параметры)
        EXECUTE имя_процедуры параметры`},
        '5':{title:`ОПЕРАТОРЫ DML
        SELECT – выборка дынных из таблицы в НАБОР ДАННЫХ
        INSERT
        UPDATE
        DELETE

        Варианты заполнения значений INSERT:
        • Обычный:
        INSERT [LOW_PRIORITY | DELAYED] [IGNORE] 
        [INTO] tbl_name [(col_name,...)] VALUES 
        (expression,...),(...),... 
        • Через select
        INSERT [LOW_PRIORITY | DELAYED] [IGNORE] 
        [INTO] tbl_name [(col_name,...)] SELECT ... 
        • Через установления прямого равенства:
        INSERT [LOW_PRIORITY | DELAYED] [IGNORE] 
        [INTO] tbl_name
        SET col_name=expression, col_name=expression, ... 

        Расшифровка:
        LOW_PRIORITY – низкий приоритет – будет выполнено когда нет клиентов
        DELAYED - позволяет пользователю продолжать работу сразу же не дожидаясь, пока инструкция вставки будет завершена 
        IGNORE - строки значений, которых дублируют существующий ключ PRIMARY или UNIQUE в таблице, игнорируются и не будут вставлены, если не определяете 
        IGNORE, вставка будет прервана, если имеется любая строка, которая дублирует существующее значение ключа. 

        Варианты заполнения значений UPDATE:
        • Одна таблица:
        UPDATE [LOW_PRIORITY] [IGNORE] имя_таблицы
        SET имя_столбца1=выражение1 
        [,имя_столбца2=выражение2 ...]
        [WHERE определение_where]
        [ORDER BY ...] 
        • Многотабличный синтаксис: 
        UPDATE [LOW_PRIORITY] [IGNORE] имя_таблицы [, 
        имя_таблицы ...] SET имя_столбца 1=выражение1 
        [,имя_столбца2=выражение2 ...] [WHERE 
        определение_where]

        Варианты DELETE:
        • Обычный:
        DELETE [LOW_PRIORITY | QUICK] FROM table_name
        [WHERE where_definition] [ORDER BY ...] 
        • Вместе со связанной таблицей:
        DELETE [LOW_PRIORITY | QUICK] table_name[.*] 
        [table_name[.*] ...] FROM table-references [WHERE 
        where_definition] 
        QUICK - не будет объединение индексов от ключевой 
        связи в течение процесса удаления, что может ускорять 
        некоторые виды удаления`},
    },
    lecture_6:{
        '0':{title:`                                                                                                                                                                Select`},
        '1':{title:`        Простой SELECT
        Оператор SELECT осуществляет выборку из базы данных и имеет наиболее сложную структуру среди всех операторов языка SQL. 
        SELECT * FROM Таблица;
        SELECT поле1, поле2, поле3, поле4, поле5
        FROM Таблица;`},
        '2':{title:`        ORDER BY. Сортировка

        SELECT                                    SELECT                                    По одному
        DISTINCT поле1, поле2           DISTINCT поле1, поле2           полю
        FROM таблица1                       FROM таблица1
        ORDER BY поле2 DESC;        ORDER BY 2 DESC;
        SELECT                                                                                      По 
        DISTINCT поле1, поле2                                                             нескольким 
        FROM таблица1                                                                         полям
        ORDER BY поле1 DESC,
        поле2 DESC;
        SELECT поле1                                                                           По полю не
        FROM таблица1                                                                         выбираемому
        ORDER BY поле2 DESC                                                           в НД;`},
        '3':{title:`        WHERE. Горизонтальная выборка:
        Условие where: операции сравнения «<» (меньше чем), «=» 
        (равно), «>» (больше), «>=» (больше или равно), «<=» (меньше 
        или равно) и «<>» (не равно). Выражения в предикатах 
        сравнения могут содержать константы и любые поля из таблиц, 
        указанных в FROM. Символьные строки и константы типа 
        дата/время записываются в апострофах.
        SELECT DISTINCT поле1, поле2
        FROM таблица
        WHERE поле1 < 500
        При этом в результирующий набор попадут только те строки из 
        источника записей, для каждой из которых значение предиката 
        равно TRUE. То есть предикат проверяется для каждой 
        записи.

        Предикат BETWEEN:
        Предикат BETWEEN проверяет, попадают ли значения проверяемого выражения в диапазон, задаваемый 
        пограничными выражениями, соединяемыми служебным словом AND. Естественно, как и для предиката 
        сравнения, выражения в предикате BETWEEN должны быть совместимы по типам.

        Предикат IN:
        Предикат IN определяет, будет ли значение проверяемого выражения обнаружено в наборе значений, который либо 
        явно определен, либо получен с помощью табличного подзапроса.

        Если целевой объект эквивалентен хотя бы одному из указанных в предложении IN значений, истинностное 
        значение предиката IN будет равно TRUE. Если для каждого значения Х в предложении IN целевой объект <> 
        X, истинностное значение будет равно FALSE. Если подзапрос выполняется, и результат не содержит ни одной строки (пустая таблица), предикат принимает 
        значение FALSE. Когда не соблюдается ни одно из упомянутых выше условий, значение предиката равно UNKNOWN.
         `},
        '4':{title:`        Регелярные выражения:
        Очень мощны механизм (например в Oracle). Регулярные 
        выражения представляют компактный и гибкий формат записи 
        условий для поиска и замены в тексте по шаблону.

        SQL server не поддерживает регулярные выражения в полной 
        мере. Но можно например сделать вот это:

        CREATE TABLE blatest(code char(3))
        ALTER TABLE blatest ADD CONSTRAINT ck_bla CHECK (code like 
        '[DMOPT][0-9][0-9]' )

        Оно допускает только буквенные символы (D, M, O, P или T) с 
        последующими двумя цифровыми символами.

        Еще в SQL server определенный набор регулярных выражений 
        может быть использован в поле Найти в диалоговом окне Найти 
        и заменить в SQL Server Management Studio.

        NULL в условиях:
        IS [NOT] NULL
        Ошибка:
        = NULL
        Это происходит потому, что сравнение с NULL-значением согласно предикату сравнения оценивается 
        как UNKNOWN. А строка попадает в результирующий набор только в том случае, если предикат в 
        предложении WHERE есть TRUE. Это же справедливо и для предиката в предложении HAVING.
        
        Аналогичной, но не такой очевидной ошибкой является сравнение с NULL в предложении CASE.
        `},
        '5':{title:`        CASE
        Ошибка (из-за =Null):                   Правильно (null сравниваетсяна is null):
        SELECT order_id,                         SELECT order_id,
        CASE date_of_completion            CASE
        WHEN null                                    WHEN date_of_completion is null
        THEN GETDATE()                        THEN GETDATE()
        ELSE '01.01.1900'                        ELSE '01.01.1900'
        END 'year'                                     END 'year'
        FROM order_                                --SELECT *
        ORDER BY date_of_issue;           FROM order_ 
                                                              --where date_of_completion is null 
                                                             ORDER BY date_of_issue;
        

        Вычисления и переименование:
        SELECT поле1*1024 AS K, поле2 G, ‘поле’ x
        FROM PC р
        WHERE поле6 = поле3*1024;
        
`},
        '6':{title:`        GROUP BY:
        GROUP BY используется для определения групп выходных строк, к которым могут применяться агрегатные функции (COUNT, MIN, MAX, AVG и SUM). Если это предложение отсутствует, и 
        используются агрегатные функции, то все столбцы с именами, упомянутыми в SELECT, должны быть включены в агрегатные функции, и эти функции будут применяться ко всему набору строк,
        которые удовлетворяют предикату запроса. В противном случае все столбцы списка SELECT, не вошедшие в агрегатные функции, должны быть 
        указаны в предложении GROUP BY. В результате чего все выходные строки запроса разбиваются на группы, характеризуемые одинаковыми комбинациями значений в этих столбцах.
        После чего к каждой группе будут применены агрегатные функции.
        Следует иметь в виду, что для GROUP BY все значения NULL трактуются как равные, то есть при группировке по полю, содержащему NULLзначения, все такие строки попадут в одну группу.
        Если при наличии предложения GROUP BY, в предложении SELECT отсутствуют агрегатные функции, то запрос просто вернет по одной строке из каждой группы.

        Агрегатные функции:

        название:                описание:
        COUNT(*)                Возвращает количество строк источника записей
        COUNT                    Возвращает количество значений в указанном столбце
        SUM                         Возвращает сумму значений в указанном столбце
        AVG                         Возвращает среднее значение в указанном столбце
        MIN                          Возвращает минимальное значение в указанномстолбце
        MAX                         Возвращает максимальное значение в указанномстолбце

        HAVING:
        Если предложение WHERE определяет предикат для фильтрации строк, то предложение HAVING применяется после группировки для 
        определения аналогичного предиката, фильтрующего группы по значениям агрегатных функций. Это предложение необходимо для 
        проверки значений, которые получены с помощью агрегатной функции не из отдельных строк источника записей, определенного в предложении FROM, а из групп таких строк. Поэтому такая 
        проверка не может содержаться в предложении WHERE. Получить количество ДЕТАЛЕЙ и среднюю цену для каждУЮДЕТАЛЬ, средняя цена которой менее 800валютных едииц
        SELECT деталь, COUNT(деталь) AS С_деталь,
            AVG(цена) AS Avg_цена
        FROM Table1
        GROUP BY деталь
        HAVING AVG(цена) < 800;`},
        '7':{title:`        Операция JOIN:
        FROM <таблица 1>
        [INNER]
        {{LEFT | RIGHT | FULL } [OUTER]}
        JOIN <таблица 2>
        ON <предикат>`},
        '8':{title:`        Операция UNION SELECT:
        CAST(поле1 AS varchar(10)) point, SUM(поле2) Q
        FROM табле1
        GROUP BY point
        UNION ALL
        SELECT поле2, SUM(поле1)
        FROM табле2;`},
        '9':{title:`        Подзапросы:
        Пример комбинации агрегированных и детализированных данных:
        SELECT поле1, поле2 _price,
                (SELECT MIN(поле2) FROM таблица1) min_price,
                (SELECT MAX(поле2) FROM таблица1) max_price
        FROM таблица1;

        Подзапрос в ограничениях:
        SELECT поле1
        FROM таблица1
        WHERE поле1 = (SELECT MIN(поле3) FROM таблица1;

        Подзапрос в источниках:
        SELECT DISTINCT T1.model, T2.maker
        FROM T1, (SELECT maker, model FROM T2)
        WHERE T1.model = T2.model AND T1.price < 6000;

        Вложенные запросы. Нет циклам:
        SELECT поле1
        FROM (SELECT DISTINCT поле1, поле2
                FROM таблица1
                WHERE поле3 IS NOT NULL
                ORDER BY поле2
                ) X;
        SELECT MAX(avg_price)
        FROM (SELECT AVG(Р.поле2) avg_price
                FROM таблица1 P 
                JOIN таблица2 PC ON P.поле2 = PC.поле1
                GROUP BY P.поле3
                ) X;`},
        '10':{title:`        Цикл WHILE 
        Declare @ имя_переменной1 тип_переменной;
        declare имя_курсора1 cursor 
        for 
                select distinct поле1
                from таблица1
        open имя_курсора1
        fetch next from имя_курсора1 into @имя_переменной1
        while @@fetch_status = 0
        begin
                fetch next from имя_курсора1 into @имя_переменной1
        end
        close имя_курсора1`},
    },
    lecture_7:{
        '0':{title:'                                                                                                                                   Операторы DCL. Роли и пользователи'},
        '1':{title:`        Требования не зависящие от данных:
        • Функционирование в доверенной среде. Под доверенной средой следует понимать инфраструктуру предприятия и ее 
            защитные механизмы, обусловленные политиками безопасности. Таким образом, речь идет о функционировании 
            СУБД в соответствии с правилами безопасности, применяемыми и ко всем прочим системам предприятия.
        • Организация физической безопасности файлов данных.
            Требования к физической безопасности файлов данных СУБД в целом не отличаются от требований, применяемых к любым другим файлам пользователей и приложений.
        • Организация безопасной и актуальной настройки СУБД.
            Данное требование включает в себя общие задачи обеспечения безопасности, такие как своевременная 
            установка обновлений, отключение неиспользуемых функций или применение эффективной политики паролей.

        Требования зависящие от данных:
        • Безопасность пользовательского ПО. Сюда можно отнести задачи построения безопасных интерфейсов и механизмов доступа к данным.
        • Безопасная организация и работа с данными. Вопрос организации данных и управления ими является ключевым в системах хранения информации. В эту область входят 
            задачи организации данных с контролем целостности и другие, специфичные для СУБД проблемы безопасности. Фактически эта задача включает в себя основной объем 
            зависящих от данных уязвимостей и защиты от них.`},
        '2':{title:`        • Даже если первоначально приложение разработано безупречно, по мере развития ИС могут появляться новые угрозы. 
        • На первой линии защиты обязательно необходимо сократить контактную зону для несанкционированного доступа. Для этого никогда не следует предоставлять больше прав доступа, чем необходимо.
        • Создание многоуровневой защиты вокруг БД позволяет свести к минимуму ущерб, причиняемый несанкционированным доступом. Стратегия всесторонней защиты с перекрывающимися уровнями 
        безопасности - это лучший способ борьбы с угрозами безопасности.`},
        '3':{title:`        Средства защиты данных:
        Физические
        Аппаратные 
        Программные
        Огранизационные
        Законодательные
        Морально-этические
        
        Методы защиты данных:
        Управление
        Препятствие
        Маскировка
        Регламентация
        Побуждение
        Принуждение`},
        '4':{title:`        Дискреционное управление доступом:
        Дискреционное управление доступам (discretionary access control) — разграничение доступа между поименованными субъектами ипоименованными объектами.
            • Минимум средствами дискреционной защиты должны
            регулироваться соединение с системой и не допускаться
            таковые для пользователей не идентифицированных и
            пользователей, подлинность идентификации которых при
            аутентификации не подтвердилась.
            • А также в процессе сеанса работы пользователя (от удачного
            прохождения идентификации и аутентификации до
            отсоединения от системы) все его действия непосредственно
            связываются с результатом идентификации. Последнее касается
            в том числе и хранимых процедур, для которых фиксируется от
            имени какого пользователя выполняется данная хранимая
            процедура в каждом конкретном случае, а не сохранение имени
            владельца хранимой процедуры.

        Недостатки дискреционного метода:
        Основной недостаток дискреционного метода управления
        доступом к данным в БД напрямую связан в субъектом,
        который наделен определенными правами, а точнее правом
        при котором он может передать доступ любому другому
        субъекту, даже нежелательному с точки зрения прочтения
        информации.
        • Действия, связанные с администрированием СУБД разделены
        по категориям:
            • системный администратор, обладающий всеми привилегиями – наивысший уровень;
            • администратор базы данных, обладающий всем набором привилегий в рамках конкретной базы данных.
        • Кроме того, необходимо рассмотреть вопрос о
        дополнительных средствах защите информации (основные
        средства защиты решены как правило в СУБД) из системного
        каталога БД, который хранить данные созданные
        администратором

        Мандатное управление доступом:
        Мандатное управление доступом (mandatory access control) — это разграничение доступа субъектов к объектам  данных, основанное на характеризуемой меткой 
        конфиденциальности информации, которая содержится в объектах, и на официальном разрешении (допуске) субъектов обращаться к информации такого уровня конфиденциальности. 
        • Использование мандатной защиты может помешать 
            авторизованному пользователю законным образом 
            получить секретную информацию и затем сделать ее 
            доступной для других, неавторизованных (нежелательных), 
            пользователей. 
        • Мандатное управление реализуется через метки 
            безопасности, описывающие группу принадлежности и 
            уровни конфиденциальности и ценности данных объекта 
            (таблицы, столбца, строки или поля). 

        Метки безопастности:
        Метки безопасности неизменны на всем протяжении существования объекта защиты и уничтожаются только вместе с ним. 
        Кроме того метки безопасности располагаются вместе с защищаемым объектом, а не в системном каталоге, как это происходит при логической защите. 
        Реализация БД с применением меток безопасности, позволяет разграничивать доступ вплоть до конкретного значения конкретного атрибута в конкретной строке конкретной таблицы. 
        Сама метка представляет собой набор значений, отражающих, например, уровень защищенности устройства, на котором хранится таблица, уровень защищенности самой 
        таблицы, уровень защищенности атрибута и уровень защищенности конкретного кортежа.

        Недостатки мандатного метода:
        • Мандатная защита не всегда возможно для реализации
        • В случае, когда реализация мандатной защиты невозможна целесообразно реализовать подобный вариант защиты с использованием сложного набора хранимых процедур.
        • Вызов таких хранимых процедур производится с абстрактными именами, и добавление метки в таблицу в последнем случае достаточно сложна и серьезно 
            уязвима со стороны действий администратора, который имеет право на изменение структуры БД (а значит и хранимых процедур, представлений) и как 
            следствие в данном случае не изолирован от управления секретными данными.`},
        '5':{title:`        Разрешения на основе ролей:
        • Если разрешения предоставляются ролям, а не пользователям, то администрирование средств безопасности упрощается.
        • Роли могут быть вложенными. Но применение слишком большого количества уровней вложенности может привести к снижению производительности СУБД.
        • Можно также вводить пользователей в состав членов предопределенных ролей базы данных в целях упрощения задачи назначения разрешений.
        • Можно предоставлять разрешения роли на уровне схемы. Пользователи автоматически наследуют разрешения на все новые объекты, создаваемые в схеме, таким образом 
            после создания новых объектов не требуется предоставлять для них разрешения

        Предопределённые роли сервера:
        • Предопределенные роли сервера имеют предопределенный набор разрешений на уровне сервера. Они предназначены для использования в администрировании SQL Server, и разрешения, 
            назначенные им, не могут быть изменены. Предопределенным ролям сервера могут назначаться имена входа без наличия учетной записи пользователя в базе данных.
        • Тщательно обосновывайте решение по добавлению пользователей к предопределенным ролям сервера. Например, роль admin позволяет пользователям вставлять 
            содержимое любого локального файла в таблицу, что может подвергнуть риску целостность данных.РОЛЬ SYSADMIN И DB_OWNER
        • Предопределенная роль сервера sysadmin включает в себя все остальные роли и имеет неограниченную область действия.
        • Члены роли sysadmin обладают безотзывными правами администратора применительно ко всем базам данных и ресурсам сервера.
        • Члены роли db_owner могут выполнять все действия по настройке конфигурации и обслуживанию базы данных`},
        '6':{title:`        Инструкции разрешения:
        • GRANT- предоставляет разрешение.
        • REVOKE - отменяет разрешение. Разрешение, в котором отказано пользователю или роли, все еще может быть унаследовано от других групп или ролей, в которые назначен участник.
        • DENY - отменяет разрешение так, что его нельзя больше унаследовать. Инструкция DENY имеет наивысший приоритет по сравнению со всеми инструкциями 
            разрешения, однако действие инструкции DENY не распространяется на владельцев объектов или на членов роли sysadmin. Если осуществляется отзыв разрешений с 
            помощью инструкции DENY на какой-либо объект по отношению к роли public, то этот отзыв распространяется на всех пользователей и все роли, кроме владельцев 
            объекта и членов роли sysadmin

        Имена входа на сервер:
        --создание имени входа на сервер
        create login Trigub123 with password = '123'
        go
        --создание пользователя
        create user Trigub for login Trigub123
        go
        
        Роли:
        --создание роли сервера
        create role AdnimBD 
        go
        --добавление члена-пользователя в роль
        alter role AdnimBD add member Trigub
        go
        
        Оператор для определения "прав":
        --выдача прав
        • grant select, insert, update, delete on [DataBase].[dbo].[Port] 
        to AdnimBD
        • grant select, insert, update, delete
        on [DataBase].[dbo].[Port](Name) to AdnimBD
        • grant execute on [DataBase].[dbo].[FuncSklad] to AdnimBD
        
        Операторы для удаления прав
        --запрет на права
        deny select on [DataBase].[dbo].[Sklad] to AdnimBD
        --удаление прав
        revoke insert on [DataBase].[dbo].[Port] to AdnimBD`},
    },
    lecture_8:{
        '0':{title:`                                                                                                                                   Транзакции и режими их изоляции. Журнализация. Операторы DCL`},
        '1':{title:`        Свойства транзакций:
        Транзакции обладают набором свойств, характеризуемым аббревиатурой АСИД (ACID):
        • А - Атомарность. Транзакция выполняется как единое целое (либо все выполняется, либо все не выполняется).
        • С - Согласованность. Транзакция переводит базу данных из одного согласованного состояния в другое согласованное состояние. Внутри транзакции согласованность базы данных 
            может нарушаться.
        • И - Изолированность. Транзакции разных пользователей не должны мешать друг другу. Иначе говоря, транзакция должна работать только с непротиворечивыми данными, не имея 
            доступа к промежуточным результатам.
        • Д - Долговечность. Результаты работы выполненной транзакции должны сохраниться в базе данных, даже если по завершении транзакции произойдет сбой системы.`},
        '2':{title:`        TCL:
        Существует два способа запуска транзакции:
        • Транзакция начинается автоматически с момента присоединения пользователя к СУБД или по завершении предыдущей транзакции (например, в Oracle).
        • Транзакция начинается специальной командой, например, BEGIN TRANSACTION или другой командой аналогичного назначения (например, в Cache).
        
        Транзакция завершается, успешно или не успешно, специальными командами или по одному из событий:
        • Команда COMMIT (успешно).
        • Команда ROLLBACK (откатить транзакцию).
        • Событие "Отключение пользователя от СУБД".
        • Событие "Сбой системы".
        • Событие "Отключение системы".`},
        '3':{title:`        Нарушение целостности:
        Два основных типа реакции СУБД на нарушение целостности:
        • Отказ выполнить "недопустимую" операцию.
        • Выполнение действий, компенсирующих нарушения 
        ограничений целостности. 

        Классификация нарушения целостности:
        По способам реализации:
        • декларативную поддержку ограничений целостности (задается DDL)
        • процедурную поддержку ограничений целостности (триггеров и хранимых процедур)
        По времени проверки:
        • Немедленно проверяемые ограничения. Проверяются непосредственно в момент выполнения операции, могущей нарушить ограничение. (первичный ключ)
        • Ограничения с отложенной проверкой. Проверяются в момент фиксации транзакции оператором COMMIT. (вторичный ключ)
        По области действия:
        • Ограничения домена (из-за отсутствия в СУБД поддержки доменов такие ограничения обычно переносятся на атрибуты).
        • Ограничения атрибута (немедленно проверяемые ограничения на допустимые значения атрибута). Реализуются почти всегда декларативно. Проверяют обычно попадание в 
            диапазон или в список. Ограничения кортежа. Это ограничения на соотношение атрибутов одного экземпляра сущности.
        • Ограничения отношения (или сущности или таблицы). Для проверки ограничения необходимо обработать все кортежи отношения. Пример реализации триггерами или процедурами.
        • Ограничения на допустимые связи.
        • Ограничения базы или схемы данных (меж табличные). Накладываются на свойства двух или более связанных между собой отношений. Пример: ссылочная целостность.`},
        '4':{title:`        Журнал транзакций:
        Журнал транзакций – это часть БД, в которую поступают данные обо всех изменениях всех объектов БД. 
        Журнал недоступен для пользователей СУБД и ИБ для него поддерживается также тщательно как и для инф. Об учетных данных пользователей СУБД.
        Форма журнала и технологии записи в журнал зависят от СУБД. В большинстве записи в журнале имеют вид:
        - Номер транзакции (присваиваются автоматически по возрастанию);
        - Состояние транзакции (варианты: завершена успешно/фиксацией, завершена не успешно/откатом, не завершена/в процессе исполнения, в ожидании);
        - Точки сохранения (явные и неявные);
        - Команды/инструкции/запросы составляющие транзакцию;
        - Копии данных ДО транзакции и ПОСЛЕ транзакции

        Файл журнала транзакций:
        Журнал транзакций – это последовательный файл, в котором фиксируются все изменения, выполняемые всеми транзакциями.
        Файл журнала транзакций разбит на две части: области рестарта (restart area) и «бесконечную» область протоколирования (logging area).
        Общие принципы восстановления:
        • Результаты зафиксированных транзакций сохранены в восстановленной БД;
        • Результаты не зафиксированных транзакций отсутствуют в восстановленной БД;

        Работа с журналом:
        1. Клиент инициирует изменение данных
        2. Страницы с данными подгружаются и изменяются
        3. Изменения записываются в журнал
        4. Устанавливаются контрольные точки, в процессе этого записываются данные зафиксированных транзакций в БД
        Журналы лучше хранить на отдельном диске:
        • Увеличивает производительность СУБД
        • Увеличивает шансы при восстановлении после сбоев 
        
        Контрольная точка:
        Журнал транзакций содержит записи о контрольных точках.
        Контрольная точка – момент синхронизации оперативной памяти с журналом транзакции и основной областью (если фиксация транзакции). При этом все буферы СУБД 
        принудительно записываются во вторичную память.Создаются контрольные точки с заданной периодичностью. Контрольные точки записываются в область рестарта файла журнала транзакций.`},
        '5':{title:`???????????????????????????????????????????`},
        '6':{title:`        Требования от свойств транзакции к восстановлению:
        Требование атомарности транзакций означает, что откатившиеся транзакции или транзакции, не успевшие завершиться, не должны оставлять никаких следов своей работы в базе данных.
        Требование долговечности означает, что данные, полученные зафиксированными транзакциями, должны сохраниться в базе, даже если в следующий за подтверждением момент произойдет сбой.
        
        Различие мягкого и жёсткого сбоя:
        • Мягкий сбой системы - утрата части или всей первичной памяти.
        • Жесткий сбой системы - отказ аппаратуры, чаще повреждение вторичной памяти.

        Восстановление после мягкого сбоя:
        Пусть создана ситуация: принята последняя контрольная точка, и через некоторое время произошел мягкий сбой. Несколько возможных вариантов поведения системы:
        • Транзакция успешно завершена до контрольной точки, все ее данные сохранены на диске. В восстановлении не нуждается.
        • Транзакция успешно завершена. Блоки журнала вытолкнуты полностью, а блоки буферов базы частично. Необходимо завершить операции, не отображенные в блоках данных.
        • Транзакция начата до последней контрольной точки и не завершилась до сбоя. Часть блоков данных и журнала переписана на диск по событию контрольной точки. 
            Результатов остальных изменений нет. Необходимо откатить транзакцию.
        • Транзакция начата после последней контрольной точки и завершилась до сбоя. Записи журнала вытолкнуты на диск. Изменения в блоках базы на диске не производились.
            Необходимо повторить все действия (накатить транзакцию).
        • Транзакция начата после последней контрольной точки и не успела завершиться до сбоя. В журнале нет сведений о ней, изменения блоков базы были только в оперативной памяти.
            Делать ничего не нужно. Транзакция должна быть повторена.

        Восстановление после жёсткого сбоя:
        Порядок действий по восстановлению БД:
        • По архивным файлам восстановить базу данных. Желательно иметь возможность восстановить базу по состоянию на предыдущий день.
        • Если журнал сохранился, то по журналу повторяются все последние успешно завершившиеся транзакции. (При этом не нужно откатывать транзакции, прерванные в результате сбоя).
        • Если журнал погиб, восстановление последних транзакций невозможно и база создается по состоянию на момент последней архивации.`},
        '7':{title:`        Четыре уровня изоляции:
        • READ UNCOMMITTED является наименее строгим уровнем изоляции, поскольку при его использовании не учитываются блокировки, размещенные другими 
            транзакциями. Транзакции, выполняемые в READ UNCOMMITTED, могут считывать измененные значения данных, которые еще не были зафиксированы другими 
            транзакциями. Это называется чтением «грязных» данных.
        • READ COMMITTED (уровень изоляции по умолчанию для многих РСУБД). Это уровень изоляции запрещает чтение «грязных» данных путем задания условия, что запросы на 
            доступ к данным не могут считывать измененные значения данных, которые еще не зафиксированы другими транзакциями. Другие транзакции все еще могут изменять, 
            вставлять или удалять данные между выполнением отдельных запросов внутри текущей транзакции, что приводит к выполнению операций чтения без возможности повторения 
            или к получению «фантомных» данных.  
         • REPEATABLE READ является более ограничительным уровнем изоляции, чем READ COMMITTED. Он включает в себя уровень изоляции READ COMMITTED и дополнительно указывает, что до 
            завершения текущей транзакции ни одна прочая транзакция не может изменять или удалять данные, считанные текущей транзакцией. Параллелизм данного уровня изоляции ниже по 
            сравнению с READ COMMITTED, поскольку блокировки совмещаемые при чтении данных сохраняются в течение транзакции, а не освобождаются после выполнения каждой инструкции.
        • SERIALIZABLE является самым строгим уровнем изоляции, поскольку при его использовании блокируются целые диапазоны данных и блокировки сохраняются до завершения транзакции. Он 
            включает в себя уровень изоляции REPEATABLE READ и добавляет ограничение, согласно которому до завершения транзакции другие транзакции не могут 
            вставлять новые строки в диапазоны строк, чтение которых осуществляется в данной транзакции.
`},
    },
    lecture_9:{
        '0':{title:`                                                                                                                                   Хранение данных и индексирование`},
        '1':{title:`?`},
        '2':{title:`?`},
        '3':{title:`?`},
        '4':{title:`?`},
        '5':{title:`?`},
    }
}

